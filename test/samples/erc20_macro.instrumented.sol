/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
pragma solidity 0.6.12;

interface IERC20 {
    event Transfer(address indexed from, address indexed to, uint value);

    event Approval(address indexed owner, address indexed spender, uint value);

    function totalSupply() external returns (uint);

    function balanceOf(address account) external returns (uint);

    function allowance(address owner, address spender) external returns (uint);

    function transfer(address recipient, uint amount) external returns (bool);

    function approve(address spender, uint amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint amount) external returns (bool);
}

library SafeMath {
    function sub(uint a, uint b) internal pure returns (uint) {
        require(b <= a, "Underflow");
        return a - b;
    }

    function add(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        require(c >= a, "Overflow");
        return c;
    }
}

library address_to_uint256_377 {
    struct S {
        mapping(address => uint256) innerM;
        address[] keys;
        mapping(address => uint256) keyIdxM;
        uint256 sum;
    }

    function addKey(S storage m, address key) private {
        uint idx = m.keyIdxM[key];
        if (idx == 0) {
            if (m.keys.length == 0) {
                m.keys.push();
            }
            m.keyIdxM[key] = m.keys.length;
            m.keys.push(key);
        }
    }

    function removeKey(S storage m, address key) private {
        uint256 idx = m.keyIdxM[key];
        if (idx == 0) return;
        if (idx != (m.keys.length - 1)) {
            address lastKey = m.keys[m.keys.length - 1];
            m.keys[idx] = lastKey;
            m.keyIdxM[lastKey] = idx;
        }
        m.keys.pop();
        delete m.keyIdxM[key];
    }

    function set(S storage m, address key, uint256 val) internal returns (uint256) {
        m.sum -= m.innerM[key];
        m.sum += val;
        m.innerM[key] = val;
        addKey(m, key);
        return m.innerM[key];
    }

    function get(S storage m, address key) internal view returns (uint256) {
        return m.innerM[key];
    }
}

library __ScribbleUtilsLib__377 {
    event AssertionFailed(string message);

    event AssertionFailedData(int eventId, bytes encodingData);

    function assertionFailed(string memory arg_0) internal {
        emit AssertionFailed(arg_0);
    }

    function assertionFailedData(int arg_0, bytes memory arg_1) internal {
        emit AssertionFailedData(arg_0, arg_1);
    }

    function isInContract() internal returns (bool res) {
        assembly {
            res := sload(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c)
        }
    }

    function setInContract(bool v) internal {
        assembly {
            sstore(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c, v)
        }
    }
}

///  #macro erc20(balances, allowances, _totalSupply);
contract ERC20Example is IERC20 {
    using SafeMath for uint;

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

    event Transfer(address indexed from, address indexed to, uint tokens);

    struct vars1 {
        uint256 old_0;
        bool __scribble_check_invs_at_end;
    }

    struct vars2 {
        bool __scribble_check_invs_at_end;
    }

    struct vars3 {
        bool __scribble_check_invs_at_end;
    }

    struct vars4 {
        bool old_1;
        uint256 old_2;
        uint256 old_3;
        uint256 old_4;
        uint256 old_5;
        uint256 old_6;
        bool __scribble_check_invs_at_end;
    }

    struct vars5 {
        uint256 old_7;
        bool __scribble_check_invs_at_end;
    }

    struct vars6 {
        bool __scribble_check_invs_at_end;
    }

    struct vars7 {
        bool old_8;
        uint256 old_9;
        uint256 old_10;
        uint256 old_11;
        uint256 old_12;
        uint256 old_13;
        uint256 old_14;
        uint256 old_15;
        bool __scribble_check_invs_at_end;
    }

    string public constant name = "ERC20Example";
    string public constant symbol = "XMPL";
    uint8 public constant decimals = 18;
    address_to_uint256_377.S internal balances;
    mapping(address => mapping(address => uint)) internal allowances;
    uint internal _totalSupply;

    constructor(uint total) public {
        vars1 memory _v;
        _v.__scribble_check_invs_at_end = !__ScribbleUtilsLib__377.isInContract();
        __ScribbleUtilsLib__377.setInContract(true);
        _v.old_0 = balances.sum;
        __ScribbleUtilsLib__377.setInContract(true);
        _totalSupply = total;
        address_to_uint256_377.set(balances, msg.sender, _totalSupply);
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__377.setInContract(false);
        if (!((balances.sum == _v.old_0) || (msg.sig == bytes4(0x00)))) {
            emit __ScribbleUtilsLib__377.AssertionFailed("005004:0096:000 2: The token has a fixed supply.");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __ScribbleUtilsLib__377.setInContract(!_v.__scribble_check_invs_at_end);
    }

    function totalSupply() override public returns (uint RET_0) {
        vars2 memory _v;
        _v.__scribble_check_invs_at_end = !__ScribbleUtilsLib__377.isInContract();
        __ScribbleUtilsLib__377.setInContract(true);
        RET_0 = _original_ERC20Example_totalSupply();
        if (!(RET_0 == balances.sum)) {
            emit __ScribbleUtilsLib__377.AssertionFailed("005642:0101:000 3: Result is equal to sum of balances");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __ScribbleUtilsLib__377.setInContract(!_v.__scribble_check_invs_at_end);
    }

    function _original_ERC20Example_totalSupply() internal view returns (uint) {
        return _totalSupply;
    }

    function balanceOf(address account) override public returns (uint RET_0) {
        vars3 memory _v;
        _v.__scribble_check_invs_at_end = !__ScribbleUtilsLib__377.isInContract();
        __ScribbleUtilsLib__377.setInContract(true);
        RET_0 = _original_ERC20Example_balanceOf(account);
        if (!(RET_0 == address_to_uint256_377.get(balances, account))) {
            emit __ScribbleUtilsLib__377.AssertionFailed("006453:0119:000 4: Returns the balance of owner in the balances mapping");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __ScribbleUtilsLib__377.setInContract(!_v.__scribble_check_invs_at_end);
    }

    function _original_ERC20Example_balanceOf(address account) internal view returns (uint) {
        return address_to_uint256_377.get(balances, account);
    }

    function transfer(address receiver, uint amount) override public returns (bool RET_0) {
        vars4 memory _v;
        _v.__scribble_check_invs_at_end = !__ScribbleUtilsLib__377.isInContract();
        __ScribbleUtilsLib__377.setInContract(true);
        _v.old_1 = address_to_uint256_377.get(balances, msg.sender) >= amount;
        _v.old_2 = address_to_uint256_377.get(balances, msg.sender);
        _v.old_3 = address_to_uint256_377.get(balances, receiver);
        _v.old_4 = address_to_uint256_377.get(balances, receiver);
        _v.old_5 = address_to_uint256_377.get(balances, msg.sender);
        _v.old_6 = balances.sum;
        RET_0 = _original_ERC20Example_transfer(receiver, amount);
        if (!(_v.old_1)) {
            emit __ScribbleUtilsLib__377.AssertionFailed("007687:0113:000 6: The sender has sufficient balance at the start");
            assert(false);
        }
        if (!((!(msg.sender != receiver)) || ((_v.old_2 - amount) == address_to_uint256_377.get(balances, msg.sender)))) {
            emit __ScribbleUtilsLib__377.AssertionFailed("007974:0100:000 7: The sender has value less balance");
            assert(false);
        }
        if (!((!(msg.sender != receiver)) || ((_v.old_3 + amount) == address_to_uint256_377.get(balances, receiver)))) {
            emit __ScribbleUtilsLib__377.AssertionFailed("008246:0095:000 8: The receiver receives _value");
            assert(false);
        }
        if (!((_v.old_4 + _v.old_5) == (address_to_uint256_377.get(balances, receiver) + address_to_uint256_377.get(balances, msg.sender)))) {
            emit __ScribbleUtilsLib__377.AssertionFailed("008535:0111:000 9: Transfer does not modify the sum of balances");
            assert(false);
        }
        if (!((balances.sum == _v.old_6) || (msg.sig == bytes4(0x00)))) {
            emit __ScribbleUtilsLib__377.AssertionFailed("008771:0096:000 2: The token has a fixed supply.");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __ScribbleUtilsLib__377.setInContract(!_v.__scribble_check_invs_at_end);
    }

    function _original_ERC20Example_transfer(address receiver, uint amount) internal returns (bool) {
        require(amount <= address_to_uint256_377.get(balances, msg.sender));
        address_to_uint256_377.set(balances, msg.sender, address_to_uint256_377.get(balances, msg.sender).sub(amount));
        address_to_uint256_377.set(balances, receiver, address_to_uint256_377.get(balances, receiver).add(amount));
        emit Transfer(msg.sender, receiver, amount);
        return true;
    }

    function approve(address delegate, uint amount) override public returns (bool RET_0) {
        vars5 memory _v;
        _v.__scribble_check_invs_at_end = !__ScribbleUtilsLib__377.isInContract();
        __ScribbleUtilsLib__377.setInContract(true);
        _v.old_7 = balances.sum;
        RET_0 = _original_ERC20Example_approve(delegate, amount);
        if (!(allowances[msg.sender][delegate] == amount)) {
            emit __ScribbleUtilsLib__377.AssertionFailed("009996:0133:000 10: spender will have an allowance of value for this sender's balance");
            assert(false);
        }
        if (!((balances.sum == _v.old_7) || (msg.sig == bytes4(0x00)))) {
            emit __ScribbleUtilsLib__377.AssertionFailed("010254:0096:000 2: The token has a fixed supply.");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __ScribbleUtilsLib__377.setInContract(!_v.__scribble_check_invs_at_end);
    }

    function _original_ERC20Example_approve(address delegate, uint amount) internal returns (bool) {
        allowances[msg.sender][delegate] = amount;
        emit Approval(msg.sender, delegate, amount);
        return true;
    }

    function allowance(address owner, address delegate) override public returns (uint RET_0) {
        vars6 memory _v;
        _v.__scribble_check_invs_at_end = !__ScribbleUtilsLib__377.isInContract();
        __ScribbleUtilsLib__377.setInContract(true);
        RET_0 = _original_ERC20Example_allowance(owner, delegate);
        if (!(RET_0 == allowances[owner][delegate])) {
            emit __ScribbleUtilsLib__377.AssertionFailed("011182:0108:000 5: Returns spenders allowance for this owner");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __ScribbleUtilsLib__377.setInContract(!_v.__scribble_check_invs_at_end);
    }

    function _original_ERC20Example_allowance(address owner, address delegate) internal view returns (uint) {
        return allowances[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint amount) override public returns (bool RET_0) {
        vars7 memory _v;
        _v.__scribble_check_invs_at_end = !__ScribbleUtilsLib__377.isInContract();
        __ScribbleUtilsLib__377.setInContract(true);
        _v.old_8 = address_to_uint256_377.get(balances, owner) >= amount;
        _v.old_9 = address_to_uint256_377.get(balances, owner);
        _v.old_10 = allowances[owner][msg.sender];
        _v.old_11 = allowances[owner][msg.sender];
        _v.old_12 = address_to_uint256_377.get(balances, buyer);
        _v.old_13 = address_to_uint256_377.get(balances, buyer);
        _v.old_14 = address_to_uint256_377.get(balances, owner);
        _v.old_15 = balances.sum;
        RET_0 = _original_ERC20Example_transferFrom(owner, buyer, amount);
        if (!(_v.old_8)) {
            emit __ScribbleUtilsLib__377.AssertionFailed("012512:0114:000 11: The sender has sufficient balance at the start");
            assert(false);
        }
        if (!((!(owner != buyer)) || ((_v.old_9 - amount) == address_to_uint256_377.get(balances, owner)))) {
            emit __ScribbleUtilsLib__377.AssertionFailed("012787:0101:000 12: The sender has value less balance");
            assert(false);
        }
        if (!((_v.old_10 - amount) == allowances[owner][msg.sender])) {
            emit __ScribbleUtilsLib__377.AssertionFailed("013011:0102:000 13: The actor has value less allowance");
            assert(false);
        }
        if (!(_v.old_11 >= amount)) {
            emit __ScribbleUtilsLib__377.AssertionFailed("013202:0098:000 14: The actor has enough allowance");
            assert(false);
        }
        if (!((!(owner != buyer)) || ((_v.old_12 + amount) == address_to_uint256_377.get(balances, buyer)))) {
            emit __ScribbleUtilsLib__377.AssertionFailed("013462:0095:000 15: The receiver receives value");
            assert(false);
        }
        if (!((_v.old_13 + _v.old_14) == (address_to_uint256_377.get(balances, buyer) + address_to_uint256_377.get(balances, owner)))) {
            emit __ScribbleUtilsLib__377.AssertionFailed("013745:0112:000 16: Transfer does not modify the sum of balances");
            assert(false);
        }
        if (!((balances.sum == _v.old_15) || (msg.sig == bytes4(0x00)))) {
            emit __ScribbleUtilsLib__377.AssertionFailed("013983:0096:000 2: The token has a fixed supply.");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __ScribbleUtilsLib__377.setInContract(!_v.__scribble_check_invs_at_end);
    }

    function _original_ERC20Example_transferFrom(address owner, address buyer, uint amount) internal returns (bool) {
        require(amount <= address_to_uint256_377.get(balances, owner));
        require(amount <= allowances[owner][msg.sender]);
        address_to_uint256_377.set(balances, owner, address_to_uint256_377.get(balances, owner).sub(amount));
        allowances[owner][msg.sender] = allowances[owner][msg.sender].sub(amount);
        address_to_uint256_377.set(balances, buyer, address_to_uint256_377.get(balances, buyer).add(amount));
        emit Transfer(owner, buyer, amount);
        return true;
    }

    /// Check only the current contract's state invariants
    function __scribble_ERC20Example_check_state_invariants_internal() internal {
        if (!(balances.sum == _totalSupply)) {
            emit __ScribbleUtilsLib__377.AssertionFailed("015112:0122:000 1: The sum of balances is always equal to the total supply");
            assert(false);
        }
    }

    /// Check the state invariant for the current contract and all its bases
    function __scribble_check_state_invariants() virtual internal {
        __scribble_ERC20Example_check_state_invariants_internal();
    }
}
