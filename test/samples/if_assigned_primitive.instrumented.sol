/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
pragma solidity 0.8.7;

contract Base {
    struct vars2 {
        uint256 old_0;
    }

    struct vars6 {
        uint256 old_1;
    }

    uint internal x = 1;
    uint internal y;
    uint internal z;
    address internal a = address(0x1);
    uint[] internal arr;

    constructor() {
        Base_a_inline_initializer();
        Base_x_inline_initializer();
        Base_y_uint256_assign(2);
        Base_x_uint256_assign(2);
        Base_a_address_assign(address(0x2));
    }

    function id(uint z) internal returns (uint) {
        return z;
    }

    function main() public {
        Base_x_inc_postfix();
        assert(x == 3);
        for (Base_x_uint256_assign(5); x < 10; Base_x_inc_postfix()) Base_y_inc_postfix();
        assert((x == 10) && (y == 7));
        Base_x_uint256_assign(Base_x_uint256_assign(5));
        assert(x == 6);
        Base_x_uint256_assign(id(Base_x_uint256_assign(6)));
        assert(x == 7);
        Base_x_delete();
        assert(x == 0);
        Base_y_uint256_assign(y + 1);
        assert(y == 8);
        Base_x_uint256_assign(Base_x_inc_postfix());
        assert(x == 0);
        Base_x_uint256_assign(Base_x_inc_prefix());
        assert(x == 1);
        arr.push(1);
        arr.push(2);
    }

    function Base_x_inline_initializer() internal {
        unchecked {
            if (!(x >= 1)) {
                emit __ScribbleUtilsLib__177.AssertionFailed("001490:0067:000 0: ");
                assert(false);
            }
        }
    }

    function Base_a_inline_initializer() internal {
        unchecked {
            if (!(uint160(a) >= 1)) {
                emit __ScribbleUtilsLib__177.AssertionFailed("001747:0067:000 2: ");
                assert(false);
            }
        }
    }

    function Base_y_uint256_assign(uint256 ARG0) internal returns (uint256 RET0) {
        vars2 memory _v;
        unchecked {
            _v.old_0 = y;
        }
        y = ARG0;
        RET0 = y;
        unchecked {
            if (!(y >= _v.old_0)) {
                emit __ScribbleUtilsLib__177.AssertionFailed("002150:0067:000 1: ");
                assert(false);
            }
        }
    }

    function Base_x_uint256_assign(uint256 ARG1) internal returns (uint256 RET1) {
        x = ARG1;
        RET1 = x;
        unchecked {
            if (!(x >= 1)) {
                emit __ScribbleUtilsLib__177.AssertionFailed("002465:0067:000 0: ");
                assert(false);
            }
        }
    }

    function Base_a_address_assign(address ARG2) internal returns (address RET2) {
        a = ARG2;
        RET2 = a;
        unchecked {
            if (!(uint160(a) >= 1)) {
                emit __ScribbleUtilsLib__177.AssertionFailed("002789:0067:000 2: ");
                assert(false);
            }
        }
    }

    function Base_x_inc_postfix() internal returns (uint256 RET3) {
        RET3 = x;
        x++;
        unchecked {
            if (!(x >= 1)) {
                emit __ScribbleUtilsLib__177.AssertionFailed("003084:0067:000 0: ");
                assert(false);
            }
        }
    }

    function Base_y_inc_postfix() internal returns (uint256 RET4) {
        vars6 memory _v;
        unchecked {
            _v.old_1 = y;
        }
        RET4 = y;
        y++;
        unchecked {
            if (!(y >= _v.old_1)) {
                emit __ScribbleUtilsLib__177.AssertionFailed("003467:0067:000 1: ");
                assert(false);
            }
        }
    }

    function Base_x_delete() internal {
        delete x;
        unchecked {
            if (!(x >= 1)) {
                emit __ScribbleUtilsLib__177.AssertionFailed("003721:0067:000 0: ");
                assert(false);
            }
        }
    }

    function Base_x_inc_prefix() internal returns (uint256 RET5) {
        ++x;
        RET5 = x;
        unchecked {
            if (!(x >= 1)) {
                emit __ScribbleUtilsLib__177.AssertionFailed("004015:0067:000 0: ");
                assert(false);
            }
        }
    }
}

library __ScribbleUtilsLib__177 {
    event AssertionFailed(string message);

    event AssertionFailedData(int eventId, bytes encodingData);

    function assertionFailed(string memory arg_0) internal {
        emit AssertionFailed(arg_0);
    }

    function assertionFailedData(int arg_0, bytes memory arg_1) internal {
        emit AssertionFailedData(arg_0, arg_1);
    }

    function isInContract() internal returns (bool res) {
        assembly {
            res := sload(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c)
        }
    }

    function setInContract(bool v) internal {
        assembly {
            sstore(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c, v)
        }
    }
}

contract Child is Base {
    function moo() public {
        Base_x_uint256_assign(1);
    }
}
