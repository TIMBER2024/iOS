/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
/// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.6.0;

interface IERC20 {
    event Transfer(address indexed from, address indexed to, uint value);

    event Approval(address indexed owner, address indexed spender, uint value);

    function totalSupply() external returns (uint);

    function balanceOf(address account) external returns (uint);

    function allowance(address owner, address spender) external returns (uint);

    function transfer(address recipient, uint amount) external returns (bool);

    function approve(address spender, uint amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint amount) external returns (bool);
}

contract ERC20 is IERC20 {
    using SafeMath for uint;

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

    event Transfer(address indexed from, address indexed to, uint tokens);

    struct vars4 {
        bool __scribble_check_invs_at_end;
    }

    struct vars5 {
        bool __scribble_check_invs_at_end;
    }

    struct vars6 {
        bool old_1;
        uint256 old_2;
        uint256 old_3;
        uint256 old_4;
        uint256 old_5;
        bool __scribble_check_invs_at_end;
    }

    struct vars7 {
        bool __scribble_check_invs_at_end;
    }

    struct vars8 {
        bool old_6;
        uint256 old_7;
        uint256 old_8;
        uint256 old_9;
        uint256 old_10;
        uint256 old_11;
        uint256 old_12;
        bool __scribble_check_invs_at_end;
    }

    string public constant name = "ERC20Example";
    string public constant symbol = "XMPL";
    uint8 public constant decimals = 18;
    address_to_uint256_406.S internal balances;
    mapping(address => mapping(address => uint)) internal allowances;
    uint internal _totalSupply;

    constructor(uint total) public {
        __ScribbleUtilsLib__406.setInContract(true);
        _totalSupply = total;
        address_to_uint256_406.set(balances, msg.sender, _totalSupply);
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__406.setInContract(false);
    }

    function totalSupply() override public returns (uint RET_0) {
        vars4 memory _v;
        _v.__scribble_check_invs_at_end = !__ScribbleUtilsLib__406.isInContract();
        __ScribbleUtilsLib__406.setInContract(true);
        RET_0 = _original_ERC20_totalSupply();
        if (!(RET_0 == balances.sum)) {
            emit __ScribbleUtilsLib__406.AssertionFailed("002569:0101:001 3: Result is equal to sum of balances");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __ScribbleUtilsLib__406.setInContract(!_v.__scribble_check_invs_at_end);
    }

    function _original_ERC20_totalSupply() internal view returns (uint) {
        return _totalSupply;
    }

    function balanceOf(address account) override public returns (uint RET_0) {
        vars5 memory _v;
        _v.__scribble_check_invs_at_end = !__ScribbleUtilsLib__406.isInContract();
        __ScribbleUtilsLib__406.setInContract(true);
        RET_0 = _original_ERC20_balanceOf(account);
        if (!(RET_0 == address_to_uint256_406.get(balances, account))) {
            emit __ScribbleUtilsLib__406.AssertionFailed("003366:0119:001 4: Returns the balance of owner in the balances mapping");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __ScribbleUtilsLib__406.setInContract(!_v.__scribble_check_invs_at_end);
    }

    function _original_ERC20_balanceOf(address account) internal view returns (uint) {
        return address_to_uint256_406.get(balances, account);
    }

    function transfer(address receiver, uint amount) override public returns (bool RET_0) {
        vars6 memory _v;
        _v.__scribble_check_invs_at_end = !__ScribbleUtilsLib__406.isInContract();
        __ScribbleUtilsLib__406.setInContract(true);
        _v.old_1 = address_to_uint256_406.get(balances, msg.sender) >= amount;
        _v.old_2 = address_to_uint256_406.get(balances, msg.sender);
        _v.old_3 = address_to_uint256_406.get(balances, receiver);
        _v.old_4 = address_to_uint256_406.get(balances, receiver);
        _v.old_5 = address_to_uint256_406.get(balances, msg.sender);
        RET_0 = _original_ERC20_transfer(receiver, amount);
        if (!(_v.old_1)) {
            emit __ScribbleUtilsLib__406.AssertionFailed("004553:0113:001 6: The sender has sufficient balance at the start");
            assert(false);
        }
        if (!((!(msg.sender != receiver)) || ((_v.old_2 - amount) == address_to_uint256_406.get(balances, msg.sender)))) {
            emit __ScribbleUtilsLib__406.AssertionFailed("004840:0100:001 7: The sender has value less balance");
            assert(false);
        }
        if (!((!(msg.sender != receiver)) || ((_v.old_3 + amount) == address_to_uint256_406.get(balances, receiver)))) {
            emit __ScribbleUtilsLib__406.AssertionFailed("005112:0095:001 8: The receiver receives _value");
            assert(false);
        }
        if (!((_v.old_4 + _v.old_5) == (address_to_uint256_406.get(balances, receiver) + address_to_uint256_406.get(balances, msg.sender)))) {
            emit __ScribbleUtilsLib__406.AssertionFailed("005401:0111:001 9: Transfer does not modify the sum of balances");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __ScribbleUtilsLib__406.setInContract(!_v.__scribble_check_invs_at_end);
    }

    function _original_ERC20_transfer(address receiver, uint amount) internal returns (bool) {
        require(amount <= address_to_uint256_406.get(balances, msg.sender));
        address_to_uint256_406.set(balances, msg.sender, address_to_uint256_406.get(balances, msg.sender).sub(amount));
        address_to_uint256_406.set(balances, receiver, address_to_uint256_406.get(balances, receiver).add(amount));
        emit Transfer(msg.sender, receiver, amount);
        return true;
    }

    function approve(address delegate, uint amount) override public returns (bool RET_0) {
        vars7 memory _v;
        _v.__scribble_check_invs_at_end = !__ScribbleUtilsLib__406.isInContract();
        __ScribbleUtilsLib__406.setInContract(true);
        RET_0 = _original_ERC20_approve(delegate, amount);
        if (!(allowances[msg.sender][delegate] == amount)) {
            emit __ScribbleUtilsLib__406.AssertionFailed("006594:0133:001 10: spender will have an allowance of value for this sender's balance");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __ScribbleUtilsLib__406.setInContract(!_v.__scribble_check_invs_at_end);
    }

    function _original_ERC20_approve(address delegate, uint amount) internal returns (bool) {
        allowances[msg.sender][delegate] = amount;
        emit Approval(msg.sender, delegate, amount);
        return true;
    }

    function allowance(address owner, address delegate) virtual override public returns (uint) {
        return allowances[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint amount) override public returns (bool RET_0) {
        vars8 memory _v;
        _v.__scribble_check_invs_at_end = !__ScribbleUtilsLib__406.isInContract();
        __ScribbleUtilsLib__406.setInContract(true);
        _v.old_6 = address_to_uint256_406.get(balances, owner) >= amount;
        _v.old_7 = address_to_uint256_406.get(balances, owner);
        _v.old_8 = allowances[owner][msg.sender];
        _v.old_9 = allowances[owner][msg.sender];
        _v.old_10 = address_to_uint256_406.get(balances, buyer);
        _v.old_11 = address_to_uint256_406.get(balances, buyer);
        _v.old_12 = address_to_uint256_406.get(balances, owner);
        RET_0 = _original_ERC20_transferFrom(owner, buyer, amount);
        if (!(_v.old_6)) {
            emit __ScribbleUtilsLib__406.AssertionFailed("008119:0114:001 11: The sender has sufficient balance at the start");
            assert(false);
        }
        if (!((!(owner != buyer)) || ((_v.old_7 - amount) == address_to_uint256_406.get(balances, owner)))) {
            emit __ScribbleUtilsLib__406.AssertionFailed("008394:0101:001 12: The sender has value less balance");
            assert(false);
        }
        if (!((_v.old_8 - amount) == allowances[owner][msg.sender])) {
            emit __ScribbleUtilsLib__406.AssertionFailed("008617:0102:001 13: The actor has value less allowance");
            assert(false);
        }
        if (!(_v.old_9 >= amount)) {
            emit __ScribbleUtilsLib__406.AssertionFailed("008807:0098:001 14: The actor has enough allowance");
            assert(false);
        }
        if (!((!(owner != buyer)) || ((_v.old_10 + amount) == address_to_uint256_406.get(balances, buyer)))) {
            emit __ScribbleUtilsLib__406.AssertionFailed("009067:0095:001 15: The receiver receives value");
            assert(false);
        }
        if (!((_v.old_11 + _v.old_12) == (address_to_uint256_406.get(balances, buyer) + address_to_uint256_406.get(balances, owner)))) {
            emit __ScribbleUtilsLib__406.AssertionFailed("009350:0112:001 16: Transfer does not modify the sum of balances");
            assert(false);
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __ScribbleUtilsLib__406.setInContract(!_v.__scribble_check_invs_at_end);
    }

    function _original_ERC20_transferFrom(address owner, address buyer, uint amount) internal returns (bool) {
        require(amount <= address_to_uint256_406.get(balances, owner));
        require(amount <= allowances[owner][msg.sender]);
        address_to_uint256_406.set(balances, owner, address_to_uint256_406.get(balances, owner).sub(amount));
        allowances[owner][msg.sender] = allowances[owner][msg.sender].sub(amount);
        address_to_uint256_406.set(balances, buyer, address_to_uint256_406.get(balances, buyer).add(amount));
        emit Transfer(owner, buyer, amount);
        return true;
    }

    /// Check only the current contract's state invariants
    function __scribble_ERC20_check_state_invariants_internal() internal {}

    /// Check the state invariant for the current contract and all its bases
    function __scribble_check_state_invariants() virtual internal {
        __scribble_ERC20_check_state_invariants_internal();
    }
}

library SafeMath {
    function sub(uint a, uint b) internal pure returns (uint) {
        require(b <= a, "Underflow");
        return a - b;
    }

    function add(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        require(c >= a, "Overflow");
        return c;
    }
}

library address_to_uint256_406 {
    struct S {
        mapping(address => uint256) innerM;
        address[] keys;
        mapping(address => uint256) keyIdxM;
        uint256 sum;
    }

    function addKey(S storage m, address key) private {
        uint idx = m.keyIdxM[key];
        if (idx == 0) {
            if (m.keys.length == 0) {
                m.keys.push();
            }
            m.keyIdxM[key] = m.keys.length;
            m.keys.push(key);
        }
    }

    function removeKey(S storage m, address key) private {
        uint256 idx = m.keyIdxM[key];
        if (idx == 0) return;
        if (idx != (m.keys.length - 1)) {
            address lastKey = m.keys[m.keys.length - 1];
            m.keys[idx] = lastKey;
            m.keyIdxM[lastKey] = idx;
        }
        m.keys.pop();
        delete m.keyIdxM[key];
    }

    function set(S storage m, address key, uint256 val) internal returns (uint256) {
        m.sum -= m.innerM[key];
        m.sum += val;
        m.innerM[key] = val;
        addKey(m, key);
        return m.innerM[key];
    }

    function get(S storage m, address key) internal view returns (uint256) {
        return m.innerM[key];
    }
}

library __ScribbleUtilsLib__406 {
    event AssertionFailed(string message);

    event AssertionFailedData(int eventId, bytes encodingData);

    function assertionFailed(string memory arg_0) internal {
        emit AssertionFailed(arg_0);
    }

    function assertionFailedData(int arg_0, bytes memory arg_1) internal {
        emit AssertionFailedData(arg_0, arg_1);
    }

    function isInContract() internal returns (bool res) {
        assembly {
            res := sload(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c)
        }
    }

    function setInContract(bool v) internal {
        assembly {
            sstore(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c, v)
        }
    }
}