/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
pragma solidity 0.8.4;

contract Foo {
    uint[] internal a = [10];
    int8[] internal b;

    function pushA(uint k) public {
        _original_Foo_pushA(k);
        unchecked {
            if (!((__ScribbleUtilsLib__91.sum_arr_uint256_arr_storage(a) > 10) && (__ScribbleUtilsLib__91.sum_arr_uint256_arr_storage(a) < 20))) {
                emit __ScribbleUtilsLib__91.AssertionFailed("000466:0066:000 0: ");
                assert(false);
            }
        }
    }

    function _original_Foo_pushA(uint k) internal {
        a.push(k);
    }

    function setA(uint k, uint v) public {
        _original_Foo_setA(k, v);
        unchecked {
            if (!((__ScribbleUtilsLib__91.sum_arr_uint256_arr_storage(a) > 10) && (__ScribbleUtilsLib__91.sum_arr_uint256_arr_storage(a) < 20))) {
                emit __ScribbleUtilsLib__91.AssertionFailed("000934:0066:000 1: ");
                assert(false);
            }
        }
    }

    function _original_Foo_setA(uint k, uint v) internal {
        a[k] = v;
    }

    function pushB(int8 k) public {
        _original_Foo_pushB(k);
        unchecked {
            if (!((__ScribbleUtilsLib__91.sum_arr_int8_arr_storage(b) > (-10)) && (__ScribbleUtilsLib__91.sum_arr_int8_arr_storage(b) < 10))) {
                emit __ScribbleUtilsLib__91.AssertionFailed("001396:0066:000 2: ");
                assert(false);
            }
        }
    }

    function _original_Foo_pushB(int8 k) internal {
        b.push(k);
    }

    function setB(uint k, int8 v) public {
        _original_Foo_setB(k, v);
        unchecked {
            if (!((__ScribbleUtilsLib__91.sum_arr_int8_arr_storage(b) > (-10)) && (__ScribbleUtilsLib__91.sum_arr_int8_arr_storage(b) < 10))) {
                emit __ScribbleUtilsLib__91.AssertionFailed("001861:0066:000 3: ");
                assert(false);
            }
        }
    }

    function _original_Foo_setB(uint k, int8 v) internal {
        b[k] = v;
    }

    function memArr(int16[] memory c) public {
        _original_Foo_memArr(c);
        unchecked {
            if (!((__ScribbleUtilsLib__91.sum_arr_int16_arr_memory(c) > (-10)) && (__ScribbleUtilsLib__91.sum_arr_int16_arr_memory(c) < 10))) {
                emit __ScribbleUtilsLib__91.AssertionFailed("002335:0066:000 4: ");
                assert(false);
            }
        }
    }

    function _original_Foo_memArr(int16[] memory c) internal {}

    function calldataArr(int16[] calldata c) external {
        _original_Foo_calldataArr(c);
        unchecked {
            if (!((__ScribbleUtilsLib__91.sum_arr_int16_arr_calldata(c) > (-10)) && (__ScribbleUtilsLib__91.sum_arr_int16_arr_calldata(c) < 10))) {
                emit __ScribbleUtilsLib__91.AssertionFailed("002808:0066:000 5: ");
                assert(false);
            }
        }
    }

    function _original_Foo_calldataArr(int16[] calldata c) internal {}

    function overflowCheck(uint[] calldata c) external {
        _original_Foo_overflowCheck(c);
        unchecked {
            if (!(__ScribbleUtilsLib__91.sum_arr_uint256_arr_calldata(c) < 10)) {
                emit __ScribbleUtilsLib__91.AssertionFailed("003225:0066:000 6: ");
                assert(false);
            }
        }
    }

    function _original_Foo_overflowCheck(uint[] calldata c) internal {}
}

library __ScribbleUtilsLib__91 {
    event AssertionFailed(string message);

    event AssertionFailedData(int eventId, bytes encodingData);

    function assertionFailed(string memory arg_0) internal {
        emit AssertionFailed(arg_0);
    }

    function assertionFailedData(int arg_0, bytes memory arg_1) internal {
        emit AssertionFailedData(arg_0, arg_1);
    }

    function isInContract() internal returns (bool res) {
        assembly {
            res := sload(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c)
        }
    }

    function setInContract(bool v) internal {
        assembly {
            sstore(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c, v)
        }
    }

    function sum_arr_uint256_arr_storage(uint256[] storage arr) internal returns (uint256 ret) {
        unchecked {
            for (uint256 idx = 0; idx < arr.length; idx++) ret += arr[idx];
        }
    }

    function sum_arr_int8_arr_storage(int8[] storage arr) internal returns (int256 ret) {
        unchecked {
            for (uint256 idx = 0; idx < arr.length; idx++) ret += arr[idx];
        }
    }

    function sum_arr_int16_arr_memory(int16[] memory arr) internal returns (int256 ret) {
        unchecked {
            for (uint256 idx = 0; idx < arr.length; idx++) ret += arr[idx];
        }
    }

    function sum_arr_int16_arr_calldata(int16[] calldata arr) internal returns (int256 ret) {
        unchecked {
            for (uint256 idx = 0; idx < arr.length; idx++) ret += arr[idx];
        }
    }

    function sum_arr_uint256_arr_calldata(uint256[] calldata arr) internal returns (uint256 ret) {
        unchecked {
            for (uint256 idx = 0; idx < arr.length; idx++) ret += arr[idx];
        }
    }
}